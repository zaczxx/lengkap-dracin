<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ZuLNaD Short Drama - Nonton Drama</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --bg-main: #0F0F0F;
      --bg-card: #1E1E1E;
      --bg-header: #17171C;
      --bg-search: #252525;
      --bg-watched: #333333;
      --primary: #FF2965;
      --text-white: #F5F5F5;
      --text-gray: #B0B0B0;
      --text-dark-gray: #808080;
      --border-subtle: rgba(255,255,255,0.06);
      --border-light: rgba(255,255,255,0.10);
      --border-lighter: rgba(255,255,255,0.12);
      --melolo: #FFD700;
      --dramabox: #FF1744;
      --reelshort: #7C4DFF;
      --freereels: #F43F5E;
      --drakor: #14b8a6;
      --shadow-card: 0 6px 24px rgba(0,0,0,0.4);
      --radius-card: 18px;
      --radius-btn: 12px;
      --radius-pill: 999px;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-main);
      color: var(--text-white);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      overflow-x: hidden;
    }

    ::-webkit-scrollbar { width: 5px; }
    ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    ::-webkit-scrollbar-track { background: transparent; }

    /* ===== NAVBAR ===== */
    .navbar {
      position: fixed; top: 0; left: 0; right: 0;
      z-index: 100;
      background: rgba(23,23,28,0.85);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-bottom: 1px solid var(--border-subtle);
      height: 60px;
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 16px;
    }

    .nav-logo {
      display: flex; align-items: center; gap: 10px; cursor: pointer;
    }

    .nav-logo-icon {
      width: 36px; height: 36px;
      background: linear-gradient(135deg, var(--primary), #a855f7);
      border-radius: 10px;
      display: flex; align-items: center; justify-content: center;
      font-weight: 800; font-size: 16px; color: #fff;
      box-shadow: 0 0 16px rgba(255,41,101,0.3);
    }

    .nav-logo-text {
      font-size: 18px; font-weight: 700; color: var(--text-white);
    }

    .nav-search {
      flex: 1; max-width: 420px; margin: 0 16px;
      position: relative;
    }

    .nav-search input {
      width: 100%;
      background: var(--bg-search);
      border: 1px solid var(--border-lighter);
      border-radius: 24px;
      padding: 10px 16px 10px 42px;
      color: var(--text-white);
      font-size: 14px;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .nav-search input:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(255,41,101,0.15);
    }

    .nav-search input::placeholder { color: var(--text-dark-gray); }

    .nav-search-icon {
      position: absolute; left: 14px; top: 50%; transform: translateY(-50%);
      color: var(--text-dark-gray); pointer-events: none;
    }

    /* ===== FAB FILTER ===== */
    .fab-filter {
      position: fixed;
      bottom: 24px; right: 24px;
      z-index: 95;
      display: flex; align-items: center; gap: 8px;
      padding: 14px 22px;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: var(--radius-pill);
      font-size: 14px; font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      box-shadow: 0 8px 28px rgba(255,41,101,0.4);
      transition: all 0.25s;
    }

    .fab-filter:hover { transform: translateY(-2px); box-shadow: 0 12px 36px rgba(255,41,101,0.5); }
    .fab-filter:active { transform: scale(0.96); }
    .fab-filter svg { flex-shrink: 0; }

    /* Filter Dialog */
    .filter-dialog-backdrop {
      display: none;
      position: fixed; inset: 0;
      z-index: 200;
      background: rgba(0,0,0,0.6);
      align-items: center; justify-content: center;
    }

    .filter-dialog-backdrop.open { display: flex; }

    .filter-dialog {
      background: var(--bg-card);
      border: 1px solid var(--border-light);
      border-radius: 20px;
      padding: 24px;
      width: 320px;
      max-width: 90vw;
      animation: fadeInUp 0.3s ease;
    }

    .filter-dialog-title {
      font-size: 18px; font-weight: 800;
      color: var(--text-white);
      margin-bottom: 16px;
    }

    .filter-option-list {
      display: flex; flex-direction: column; gap: 10px;
    }

    .filter-option-btn {
      display: block; width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      font-size: 14px; font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      text-align: left;
      transition: all 0.2s;
      border: 1px solid var(--border-lighter);
      background: rgba(255,255,255,0.04);
      color: var(--text-dark-gray);
    }

    .filter-option-btn:hover { background: rgba(255,255,255,0.08); }

    .filter-option-btn.selected {
      border-color: var(--opt-color);
      background: var(--opt-bg);
      color: var(--opt-color);
    }

    .filter-dialog-close {
      margin-top: 16px;
      width: 100%;
      padding: 10px;
      background: none;
      border: none;
      color: var(--text-white);
      font-size: 14px; font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      border-radius: 10px;
      transition: background 0.2s;
    }

    .filter-dialog-close:hover { background: rgba(255,255,255,0.06); }

    /* ===== BOTTOM NAV (Mobile) ===== */
    .bottom-nav {
      display: none;
      position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%);
      z-index: 100;
      background: linear-gradient(180deg, var(--bg-header), var(--bg-card));
      border: 1px solid var(--border-light);
      border-radius: 30px;
      padding: 6px 8px;
      gap: 4px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.6);
    }

    .bottom-nav-item {
      display: flex; flex-direction: column; align-items: center;
      gap: 2px; padding: 8px 16px;
      border-radius: 20px; cursor: pointer;
      transition: all 0.2s; color: var(--text-dark-gray);
      font-size: 10px; font-weight: 500;
      text-decoration: none; border: none; background: none;
    }

    .bottom-nav-item.active {
      color: var(--primary);
      background: rgba(255,41,101,0.12);
    }

    .bottom-nav-item svg { width: 22px; height: 22px; }

    /* ===== TABS ===== */
    .tabs-bar {
      position: fixed; top: 60px; left: 0; right: 0;
      z-index: 90;
      background: rgba(15,15,15,0.9);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border-subtle);
      display: flex; align-items: center;
      padding: 0 16px;
      gap: 4px;
      overflow-x: auto;
    }

    .tab-btn {
      padding: 12px 20px;
      font-size: 14px; font-weight: 600;
      color: var(--text-dark-gray);
      background: none; border: none;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .tab-btn.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
    }

    .tab-btn:hover { color: var(--text-gray); }

    /* ===== MAIN CONTENT ===== */
    .main-content {
      padding-top: 110px;
      padding-bottom: 80px;
      min-height: 100vh;
    }

    .container {
      max-width: 1280px; margin: 0 auto;
      padding: 0 16px;
    }

    /* ===== DRAMA GRID ===== */
    .drama-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 16px;
    }

    .drama-card {
      position: relative;
      border-radius: var(--radius-card);
      overflow: hidden;
      cursor: pointer;
      box-shadow: var(--shadow-card);
      border: 1px solid var(--border-light);
      transition: transform 0.25s cubic-bezier(0.16, 1, 0.3, 1), box-shadow 0.25s;
      aspect-ratio: 0.68;
      background: var(--bg-card);
    }

    .drama-card:hover {
      transform: translateY(-6px);
      box-shadow: 0 12px 32px rgba(0,0,0,0.6);
      border-color: rgba(255,255,255,0.15);
    }

    .drama-card img {
      width: 100%; height: 100%;
      object-fit: cover;
    }

    .drama-card-overlay {
      position: absolute; bottom: 0; left: 0; right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.95));
      padding: 40px 10px 10px;
    }

    .drama-card-title {
      font-size: 13px; font-weight: 800;
      color: #fff;
      line-height: 1.3;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .drama-card-badge {
      position: absolute; top: 8px; left: 8px;
      padding: 3px 8px;
      border-radius: 8px;
      font-size: 10px; font-weight: 700;
    }

    .drama-card-ep {
      position: absolute; top: 8px; right: 8px;
      background: rgba(0,0,0,0.7);
      padding: 3px 8px;
      border-radius: 8px;
      font-size: 10px; font-weight: 600;
      color: var(--text-white);
    }

    .badge-melolo { background: rgba(255,215,0,0.18); color: var(--melolo); border: 1px solid rgba(255,215,0,0.4); }
    .badge-dramabox { background: rgba(255,23,68,0.18); color: var(--dramabox); border: 1px solid rgba(255,23,68,0.4); }
    .badge-reelshort { background: rgba(124,77,255,0.18); color: var(--reelshort); border: 1px solid rgba(124,77,255,0.4); }
    .badge-freereels { background: rgba(244,63,94,0.18); color: var(--freereels); border: 1px solid rgba(244,63,94,0.4); }
    .badge-drakor { background: rgba(20,184,166,0.18); color: var(--drakor); border: 1px solid rgba(20,184,166,0.4); }

    /* ===== DETAIL VIEW ===== */
    .detail-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      z-index: 200;
      background: var(--bg-main);
      overflow-y: auto;
      display: none;
    }

    .detail-overlay.open { display: block; }

    .player-container {
      position: relative;
      width: 100%;
      aspect-ratio: 9/16;
      background: #000;
      max-height: 90vh;
    }

    .player-container video {
      width: 100%; height: 100%;
      object-fit: contain;
      background: #000;
    }

    .player-overlay {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      display: flex; flex-direction: column;
      justify-content: space-between;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .player-overlay > * { pointer-events: auto; }

    .player-top-bar {
      display: flex; align-items: center; gap: 12px;
      padding: 12px 16px;
      background: linear-gradient(rgba(0,0,0,0.7), transparent);
    }

    .player-back-btn {
      background: rgba(255,255,255,0.1);
      border: none; border-radius: 50%;
      width: 38px; height: 38px;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; color: #fff;
      transition: background 0.2s;
    }

    .player-back-btn:hover { background: rgba(255,255,255,0.2); }

    .player-title {
      font-size: 15px; font-weight: 600; color: #fff;
      flex: 1;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }

    .player-bottom-bar {
      padding: 12px 16px;
      background: linear-gradient(transparent, rgba(0,0,0,0.8));
    }

    .player-controls {
      display: flex; align-items: center; gap: 12px;
    }

    .player-play-btn {
      background: none; border: none;
      cursor: pointer; color: #fff;
      display: flex; align-items: center; justify-content: center;
    }

    .player-time {
      font-size: 12px; color: var(--text-gray);
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    .player-seek {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      background: rgba(255,255,255,0.2);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }

    .player-seek::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px; height: 14px;
      background: var(--primary);
      border-radius: 50%;
      cursor: pointer;
    }

    .player-quality-btn {
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      padding: 4px 10px;
      color: #fff; font-size: 11px; font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    .player-quality-btn:hover { background: rgba(255,255,255,0.25); }

    .player-fullscreen-btn {
      background: none; border: none;
      cursor: pointer; color: #fff;
      display: flex; align-items: center; justify-content: center;
    }

    .player-loading {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
    }

    .spinner {
      width: 48px; height: 48px;
      border: 4px solid rgba(255,255,255,0.15);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* ===== DETAIL INFO ===== */
    .detail-info {
      padding: 20px 16px;
      max-width: 960px;
      margin: 0 auto;
    }

    .detail-title {
      font-size: 24px; font-weight: 800;
      color: var(--text-white);
      margin-bottom: 12px;
      line-height: 1.2;
    }

    .detail-chips {
      display: flex; flex-wrap: wrap; gap: 8px;
      margin-bottom: 16px;
    }

    .info-chip {
      padding: 5px 14px;
      border-radius: var(--radius-pill);
      font-size: 12px; font-weight: 600;
    }

    .chip-primary { background: rgba(255,41,101,0.16); color: var(--primary); border: 1px solid rgba(255,41,101,0.4); }
    .chip-gray { background: rgba(255,255,255,0.06); color: var(--text-gray); border: 1px solid rgba(255,255,255,0.1); }

    .detail-tags {
      display: flex; flex-wrap: wrap; gap: 6px;
      margin-bottom: 16px;
    }

    .tag-pill {
      padding: 4px 12px;
      border-radius: var(--radius-pill);
      font-size: 11px; font-weight: 500;
      background: transparent;
      color: var(--primary);
      border: 1px solid rgba(255,41,101,0.3);
    }

    .detail-synopsis {
      background: var(--bg-header);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 16px;
      margin-bottom: 20px;
    }

    .detail-synopsis h3 {
      font-size: 15px; font-weight: 700;
      color: var(--text-white);
      margin-bottom: 8px;
    }

    .detail-synopsis p {
      font-size: 13px; color: var(--text-gray);
      line-height: 1.6;
    }

    /* ===== EPISODE LIST ===== */
    .episode-header {
      display: flex; align-items: center; justify-content: space-between;
      margin-bottom: 12px;
    }

    .episode-header h3 {
      font-size: 16px; font-weight: 700;
      color: var(--text-white);
    }

    .episode-counter {
      font-size: 13px; color: var(--primary); font-weight: 600;
    }

    .episode-list {
      display: flex; flex-direction: column; gap: 6px;
    }

    .episode-item {
      display: flex; align-items: center; gap: 12px;
      padding: 12px 14px;
      border-radius: 12px;
      background: rgba(30,30,30,0.7);
      border: 1px solid var(--border-subtle);
      cursor: pointer;
      transition: all 0.2s;
    }

    .episode-item:hover {
      background: rgba(255,41,101,0.08);
      border-color: rgba(255,41,101,0.2);
    }

    .episode-item.active {
      background: rgba(255,41,101,0.15);
      border-color: rgba(255,41,101,0.5);
    }

    .episode-item.active .ep-label { color: var(--primary); }
    .episode-item.active .ep-icon { color: var(--primary); }

    .ep-icon {
      color: var(--text-gray);
      display: flex; align-items: center; justify-content: center;
      flex-shrink: 0;
    }

    .ep-label {
      font-size: 14px; font-weight: 500;
      color: var(--text-white);
      flex: 1;
    }

    /* ===== LOADING STATES ===== */
    .grid-loader {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 16px;
      margin-top: 8px;
    }

    .skeleton {
      border-radius: var(--radius-card);
      aspect-ratio: 0.68;
      background: linear-gradient(110deg, var(--bg-card) 30%, #2a2a2a 50%, var(--bg-card) 70%);
      background-size: 200% 100%;
      animation: shimmer 1.5s ease-in-out infinite;
    }

    @keyframes shimmer { to { background-position: -200% 0; } }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-dark-gray);
    }

    .empty-state svg { margin-bottom: 16px; opacity: 0.4; }
    .empty-state h3 { font-size: 18px; font-weight: 600; margin-bottom: 8px; color: var(--text-gray); }
    .empty-state p { font-size: 14px; }

    /* ===== LOAD MORE ===== */
    .load-more-btn {
      display: block; margin: 24px auto;
      padding: 12px 40px;
      background: rgba(255,41,101,0.12);
      color: var(--primary);
      border: 1px solid rgba(255,41,101,0.3);
      border-radius: var(--radius-pill);
      font-size: 14px; font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .load-more-btn:hover {
      background: rgba(255,41,101,0.2);
    }

    .load-more-btn:disabled {
      opacity: 0.5; cursor: not-allowed;
    }

    /* ===== QUALITY DROPDOWN ===== */
    .quality-dropdown {
      position: absolute; bottom: 60px; right: 16px;
      background: rgba(30,30,36,0.95);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border-light);
      border-radius: 12px;
      padding: 6px;
      display: none; z-index: 20;
      min-width: 120px;
    }

    .quality-dropdown.open { display: block; }

    .quality-option {
      display: block; width: 100%;
      padding: 8px 14px;
      background: none; border: none;
      color: var(--text-white);
      font-size: 13px; font-weight: 500;
      cursor: pointer;
      border-radius: 8px;
      text-align: left;
      transition: background 0.15s;
    }

    .quality-option:hover { background: rgba(255,255,255,0.08); }
    .quality-option.active { color: var(--primary); font-weight: 700; }

    /* ===== FADE ANIMATIONS ===== */
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(16px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .fade-in { animation: fadeInUp 0.5s cubic-bezier(0.16,1,0.3,1) forwards; }

    .drama-card { opacity: 0; animation: fadeInUp 0.5s cubic-bezier(0.16,1,0.3,1) forwards; }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      .bottom-nav { display: flex; }
      .fab-filter { bottom: 90px; right: 16px; padding: 12px; }
      .fab-filter .fab-label { display: none; }
      .drama-grid { grid-template-columns: repeat(3, 1fr); gap: 10px; }
      .grid-loader { grid-template-columns: repeat(3, 1fr); gap: 10px; }
      .nav-search { margin: 0 8px; }
      .detail-title { font-size: 20px; }
      .main-content { padding-bottom: 100px; }
    }

    @media (max-width: 480px) {
      .drama-grid { grid-template-columns: repeat(2, 1fr); gap: 8px; }
      .grid-loader { grid-template-columns: repeat(2, 1fr); gap: 8px; }
    }

    @media (min-width: 1200px) {
      .drama-grid { grid-template-columns: repeat(6, 1fr); }
    }
  </style>
</head>
<body>

<!-- ===== NAVIGATION BAR ===== -->
<nav class="navbar">
  <div class="nav-logo" onclick="goHome()">
    <div class="nav-logo-icon">SX</div>
    <span class="nav-logo-text">ZuLNaD Short Drama</span>
  </div>

  <div class="nav-search">
    <svg class="nav-search-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
    <input type="text" id="searchInput" placeholder="Cari drama..." onkeydown="if(event.key==='Enter')doSearch()">
  </div>

</nav>

<!-- ===== FAB FILTER ===== -->
<button class="fab-filter" id="fabFilter" onclick="openFilterDialog()">
  <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"/></svg>
  <span class="fab-label">Filter</span>
</button>

<!-- ===== FILTER DIALOG ===== -->
<div class="filter-dialog-backdrop" id="filterDialogBackdrop" onclick="if(event.target===this)closeFilterDialog()">
  <div class="filter-dialog">
    <div class="filter-dialog-title">Filter Sumber</div>
    <div class="filter-option-list" id="filterOptionList">
      <button class="filter-option-btn selected" data-source="all" style="--opt-color:var(--text-white);--opt-bg:rgba(255,255,255,0.1)" onclick="selectFilter('all')">Semua</button>
      <button class="filter-option-btn" data-source="melolo" style="--opt-color:var(--melolo);--opt-bg:rgba(255,215,0,0.15)" onclick="selectFilter('melolo')">Melolo</button>
      <button class="filter-option-btn" data-source="dramabox" style="--opt-color:var(--dramabox);--opt-bg:rgba(255,23,68,0.15)" onclick="selectFilter('dramabox')">Dramabox</button>
      <button class="filter-option-btn" data-source="reelshort" style="--opt-color:var(--reelshort);--opt-bg:rgba(124,77,255,0.15)" onclick="selectFilter('reelshort')">ReelShort</button>
      <button class="filter-option-btn" data-source="freereels" style="--opt-color:var(--freereels);--opt-bg:rgba(244,63,94,0.15)" onclick="selectFilter('freereels')">FreeReels</button>
      <button class="filter-option-btn" data-source="drakor" style="--opt-color:var(--drakor);--opt-bg:rgba(20,184,166,0.15)" onclick="selectFilter('drakor')">Drakor</button>
    </div>
    <button class="filter-dialog-close" onclick="closeFilterDialog()">Tutup</button>
  </div>
</div>

<!-- ===== TABS BAR ===== -->
<div class="tabs-bar">
  <button class="tab-btn active" data-tab="home" onclick="switchTab('home')">Home</button>
  <button class="tab-btn" data-tab="new" onclick="switchTab('new')">Terbaru</button>
  <button class="tab-btn" data-tab="populer" onclick="switchTab('populer')">Populer</button>
  <button class="tab-btn" data-tab="search" onclick="switchTab('search')">Pencarian</button>
</div>

<!-- ===== MAIN CONTENT ===== -->
<main class="main-content">
  <div class="container">
    <div id="dramaGrid" class="drama-grid"></div>
    <div id="gridLoader" class="grid-loader" style="display:none;"></div>
    <div id="emptyState" class="empty-state" style="display:none;">
      <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0016 9.5 6.5 6.5 0 109.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zM9.5 14C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
      <h3>Tidak ada drama</h3>
      <p>Coba cari dengan kata kunci lain</p>
    </div>
    <button id="loadMoreBtn" class="load-more-btn" style="display:none;" onclick="loadMore()">Muat Lebih Banyak</button>
  </div>
</main>

<!-- ===== BOTTOM NAVIGATION (Mobile) ===== -->
<div class="bottom-nav">
  <button class="bottom-nav-item active" data-tab="home" onclick="switchTab('home')">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
    <span>Home</span>
  </button>
  <button class="bottom-nav-item" data-tab="new" onclick="switchTab('new')">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-8 12.5v-9l6 4.5-6 4.5z"/></svg>
    <span>Terbaru</span>
  </button>
  <button class="bottom-nav-item" data-tab="populer" onclick="switchTab('populer')">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"/></svg>
    <span>Populer</span>
  </button>
  <button class="bottom-nav-item" data-tab="search" onclick="switchTab('search'); document.getElementById('searchInput').focus();">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0016 9.5 6.5 6.5 0 109.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zM9.5 14C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
    <span>Cari</span>
  </button>
  <button class="bottom-nav-item" data-tab="library" onclick="switchTab('library')">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/></svg>
    <span>Riwayat</span>
  </button>
</div>

<!-- ===== DETAIL OVERLAY ===== -->
<div class="detail-overlay" id="detailOverlay">
  <!-- Player -->
  <div class="player-container" id="playerContainer">
    <video id="videoPlayer" playsinline></video>
    <div class="player-loading" id="playerLoading" style="display:none;"><div class="spinner"></div></div>
    <div class="player-overlay" id="playerOverlayControls">
      <div class="player-top-bar">
        <button class="player-back-btn" onclick="closeDetail()">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
        </button>
        <span class="player-title" id="playerTitle">-</span>
      </div>
      <div class="player-bottom-bar">
        <div class="player-controls">
          <button class="player-play-btn" id="playPauseBtn" onclick="togglePlay()">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor" id="playIcon"><path d="M8 5v14l11-7z"/></svg>
          </button>
          <span class="player-time" id="timeDisplay">0:00 / 0:00</span>
          <input type="range" class="player-seek" id="seekBar" min="0" max="100" value="0" oninput="seekVideo(this.value)">
          <button class="player-quality-btn" id="qualityBtn" onclick="toggleQualityMenu()">720p</button>
          <button class="player-fullscreen-btn" onclick="toggleFullscreen()">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
          </button>
        </div>
      </div>
    </div>
    <div class="quality-dropdown" id="qualityDropdown"></div>
  </div>

  <!-- Detail Info -->
  <div class="detail-info" id="detailInfo">
    <h1 class="detail-title" id="detailTitle">-</h1>
    <div class="detail-chips" id="detailChips"></div>
    <div class="detail-tags" id="detailTags"></div>
    <div class="detail-synopsis">
      <h3>Sinopsis</h3>
      <p id="detailSynopsis">-</p>
    </div>
    <div class="episode-header">
      <h3>Daftar Episode</h3>
      <span class="episode-counter" id="episodeCounter">0 / 0</span>
    </div>
    <div class="episode-list" id="episodeList"></div>
  </div>
</div>

<script>
  // ============================================
  // APP STATE
  // ============================================
  const API = "https://api.sonzaix.indevs.in";
  const SOURCES = ['melolo', 'dramabox', 'reelshort', 'freereels', 'drakor'];

  let state = {
    currentTab: 'home',
    currentSource: 'all',
    activeSources: new Set(SOURCES),
    dramas: [],
    page: {},
    loading: false,
    searchQuery: '',
    // Detail state
    detailOpen: false,
    currentDrama: null,
    currentEpisodes: [],
    currentEpIndex: -1,
    currentStreamData: null,
    currentQualities: [],
    selectedQuality: '',
    hlsInstance: null,
    currentSubtitles: [],
    // History
    watchHistory: JSON.parse(localStorage.getItem('sx_history') || '[]'),
  };

  // ============================================
  // SOURCE CONFIGS
  // ============================================
  const SOURCE_CONFIG = {
    melolo: {
      label: 'Melolo', color: '#FFD700',
      endpoints: { home: '/melolo/home', new: '/melolo/new', populer: '/melolo/populer', search: '/melolo/search' },
      detailUrl: (id) => `/melolo/detail/${id}`,
      streamUrl: (vid) => `/melolo/stream/${vid}`,
      parseList: (data) => (data?.data || []).flatMap(d => (d.books || []).map(b => ({ ...b, source: 'melolo' }))),
      parseDetail: (data) => data?.data || {},
      parseStream: (data) => data?.data || {},
      getEpisodeStreamId: (ep) => ep.video_id,
    },
    dramabox: {
      label: 'Dramabox', color: '#FF1744',
      endpoints: { home: '/dramabox/home', new: '/dramabox/new', populer: '/dramabox/populer', search: '/dramabox/search' },
      detailUrl: (id) => `/dramabox/detail?id=${id}`,
      streamUrl: (id, idx) => `/dramabox/stream?dramaId=${id}&episodeIndex=${idx}`,
      parseList: (data) => (data?.data || []).flatMap(d => (d.books || []).map(b => ({ ...b, source: 'dramabox' }))),
      parseDetail: (data) => data?.data || {},
      parseStream: (data) => data?.data || {},
      getEpisodeStreamId: (ep, idx) => idx,
    },
    reelshort: {
      label: 'ReelShort', color: '#7C4DFF',
      endpoints: { home: '/reelshort/home', new: '/reelshort/new', populer: '/reelshort/populer', search: '/reelshort/search' },
      detailUrl: (id) => `/reelshort/detail?bookId=${id}`,
      streamUrl: (id, epNum) => `/reelshort/stream?bookId=${id}&episodeNumber=${epNum}`,
      parseList: (data) => (data?.data || []).flatMap(d => (d.books || []).map(b => ({ ...b, source: 'reelshort' }))),
      parseDetail: (data) => data?.data || {},
      parseStream: (data) => data?.data || {},
      getEpisodeStreamId: (ep, idx) => idx + 1,
    },
    freereels: {
      label: 'FreeReels', color: '#F43F5E',
      endpoints: { home: '/freereels/home', new: '/freereels/new', populer: '/freereels/populer', search: '/freereels/search' },
      detailUrl: (id) => `/freereels/detail?dramaId=${id}`,
      streamUrl: (id, ep) => `/freereels/stream?dramaId=${id}&episode=${ep}`,
      parseList: (data) => (data?.data || []).flatMap(d => (d.books || []).map(b => ({ ...b, source: 'freereels' }))),
      parseDetail: (data) => data?.data || {},
      parseStream: (data) => data?.data || {},
      getEpisodeStreamId: (ep, idx) => idx + 1,
    },
    drakor: {
      label: 'Drakor', color: '#14b8a6',
      endpoints: { home: null, new: null, populer: null, search: '/drama/search' },
      detailUrl: (id) => `/drama/info?id=${id}`,
      streamUrl: (sid) => `/drama/stream?id=${sid}`,
      parseList: (data) => (data?.data || []).map(item => ({
        drama_name: item.title || '',
        drama_id: item.id || '',
        description: '',
        episode_count: '',
        watch_value: item.hits || '',
        thumb_url: item.image || '',
        tags: [],
        source: 'drakor'
      })),
      parseDetail: (data) => data,
      parseStream: (data) => data,
      getEpisodeStreamId: (ep) => ep.streaming_id || ep.id,
    }
  };

  // ============================================
  // HELPERS
  // ============================================
  function $(id) { return document.getElementById(id); }

  function fmtTime(s) {
    if (!s || isNaN(s)) return '0:00';
    const m = Math.floor(s / 60);
    const sec = Math.floor(s % 60);
    return m + ':' + (sec < 10 ? '0' : '') + sec;
  }

  async function apiFetch(path) {
    const sep = path.includes('?') ? '&' : '?';
    const resp = await fetch(API + path + sep + '_t=' + Date.now());
    if (!resp.ok) throw new Error('API error ' + resp.status);
    return resp.json();
  }

  function showLoader() {
    const loader = $('gridLoader');
    loader.innerHTML = Array.from({length: 12}, () => '<div class="skeleton"></div>').join('');
    loader.style.display = 'grid';
  }

  function hideLoader() { $('gridLoader').style.display = 'none'; }

  function saveHistory(drama, source, epIndex) {
    const entry = { id: drama.drama_id, name: drama.drama_name, thumb: drama.thumb_url || drama.image, source, epIndex, time: Date.now() };
    state.watchHistory = state.watchHistory.filter(h => !(h.id === entry.id && h.source === entry.source));
    state.watchHistory.unshift(entry);
    if (state.watchHistory.length > 50) state.watchHistory = state.watchHistory.slice(0, 50);
    localStorage.setItem('sx_history', JSON.stringify(state.watchHistory));
  }

  // ============================================
  // RENDERING
  // ============================================
  function renderDramas(dramas, append = false) {
    const grid = $('dramaGrid');
    const empty = $('emptyState');

    if (!append) grid.innerHTML = '';

    if (!dramas.length && !append) {
      empty.style.display = 'block';
      return;
    }
    empty.style.display = 'none';

    dramas.forEach((d, i) => {
      const card = document.createElement('div');
      card.className = 'drama-card';
      card.style.animationDelay = (i * 0.05) + 's';

      const src = d.source || 'melolo';
      const config = SOURCE_CONFIG[src];
      const thumbUrl = proxyThumb(d.thumb_url || d.image || '', src);
      const epCount = d.episode_count || '';

      card.innerHTML = `
        <img src="${thumbUrl}" alt="" loading="lazy" onerror="this.style.display='none'">
        <div class="drama-card-badge badge-${src}">${config?.label || src}</div>
        ${epCount ? `<div class="drama-card-ep">${epCount} Ep</div>` : ''}
        <div class="drama-card-overlay">
          <div class="drama-card-title">${d.drama_name || ''}</div>
        </div>
      `;
      card.onclick = () => openDetail(d, src);
      grid.appendChild(card);
    });
  }

  function renderHistory() {
    const grid = $('dramaGrid');
    const empty = $('emptyState');
    grid.innerHTML = '';

    if (!state.watchHistory.length) {
      empty.style.display = 'block';
      empty.querySelector('h3').textContent = 'Belum ada riwayat';
      empty.querySelector('p').textContent = 'Drama yang kamu tonton akan muncul di sini';
      return;
    }
    empty.style.display = 'none';

    state.watchHistory.forEach((h, i) => {
      const card = document.createElement('div');
      card.className = 'drama-card';
      card.style.animationDelay = (i * 0.05) + 's';
      const src = h.source || 'melolo';
      const config = SOURCE_CONFIG[src];

      card.innerHTML = `
        <img src="${proxyThumb(h.thumb || '', src)}" alt="" loading="lazy" onerror="this.style.display='none'">
        <div class="drama-card-badge badge-${src}">${config?.label || src}</div>
        <div class="drama-card-ep">Ep ${(h.epIndex || 0) + 1}</div>
        <div class="drama-card-overlay">
          <div class="drama-card-title">${h.name || ''}</div>
        </div>
      `;
      card.onclick = () => openDetail({ drama_id: h.id, drama_name: h.name, thumb_url: h.thumb }, src);
      grid.appendChild(card);
    });
  }

  // ============================================
  // DATA FETCHING
  // ============================================
  async function fetchTab(tab, page = 1) {
    state.loading = true;
    showLoader();

    const sources = state.currentSource === 'all'
      ? SOURCES.filter(s => SOURCE_CONFIG[s].endpoints[tab])
      : (SOURCE_CONFIG[state.currentSource]?.endpoints[tab] ? [state.currentSource] : []);

    if (!sources.length) {
      hideLoader();
      state.loading = false;
      if (page === 1) renderDramas([]);
      return;
    }

    try {
      const results = await Promise.allSettled(
        sources.map(async src => {
          const cfg = SOURCE_CONFIG[src];
          let endpoint = cfg.endpoints[tab];
          if (!endpoint) return [];
          if (tab === 'search') {
            endpoint += (endpoint.includes('?') ? '&' : '?') + 'q=' + encodeURIComponent(state.searchQuery);
            if (src === 'reelshort') endpoint = endpoint.replace('q=', 'query=');
          }
          endpoint += (endpoint.includes('?') ? '&' : '?') + 'page=' + page;
          const data = await apiFetch(endpoint);
          return cfg.parseList(data);
        })
      );

      const allDramas = results
        .filter(r => r.status === 'fulfilled')
        .flatMap(r => r.value);

      // Interleave sources for variety
      const grouped = {};
      allDramas.forEach(d => {
        if (!grouped[d.source]) grouped[d.source] = [];
        grouped[d.source].push(d);
      });

      const interleaved = [];
      let maxLen = Math.max(...Object.values(grouped).map(g => g.length), 0);
      for (let i = 0; i < maxLen; i++) {
        for (const src of sources) {
          if (grouped[src] && grouped[src][i]) interleaved.push(grouped[src][i]);
        }
      }

      if (page === 1) {
        state.dramas = interleaved;
        renderDramas(interleaved);
      } else {
        state.dramas = state.dramas.concat(interleaved);
        renderDramas(interleaved, true);
      }

      $('loadMoreBtn').style.display = interleaved.length >= 5 ? 'block' : 'none';

    } catch(e) {
      console.error('Fetch error:', e);
    }

    hideLoader();
    state.loading = false;
  }

  // ============================================
  // TAB / SOURCE SWITCHING
  // ============================================
  function switchTab(tab) {
    state.currentTab = tab;
    state.page = {};

    // Update tab buttons
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
    document.querySelectorAll('.bottom-nav-item').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));

    $('dramaGrid').innerHTML = '';
    $('emptyState').style.display = 'none';
    $('loadMoreBtn').style.display = 'none';

    if (tab === 'library') {
      renderHistory();
      return;
    }

    if (tab === 'search') {
      const q = $('searchInput').value.trim();
      if (q) {
        state.searchQuery = q;
        fetchTab('search', 1);
      } else {
        $('emptyState').style.display = 'block';
        $('emptyState').querySelector('h3').textContent = 'Cari Drama Favoritmu';
        $('emptyState').querySelector('p').textContent = 'Ketik judul drama di kolom pencarian di atas';
      }
      return;
    }

    fetchTab(tab, 1);
  }

  function setSource(source) {
    state.currentSource = source;
    updateFilterButtons();
    switchTab(state.currentTab);
  }

  function openFilterDialog() {
    updateFilterButtons();
    $('filterDialogBackdrop').classList.add('open');
  }

  function closeFilterDialog() {
    $('filterDialogBackdrop').classList.remove('open');
  }

  function selectFilter(source) {
    setSource(source);
    closeFilterDialog();
  }

  function updateFilterButtons() {
    document.querySelectorAll('.filter-option-btn').forEach(btn => {
      btn.classList.toggle('selected', btn.dataset.source === state.currentSource);
    });
  }

  function doSearch() {
    const q = $('searchInput').value.trim();
    if (!q) return;
    state.searchQuery = q;
    switchTab('search');
  }

  function loadMore() {
    const tab = state.currentTab;
    if (!state.page[tab]) state.page[tab] = 1;
    state.page[tab]++;
    fetchTab(tab, state.page[tab]);
  }

  function goHome() {
    closeDetail();
    switchTab('home');
  }

  // ============================================
  // DETAIL / PLAYER
  // ============================================
  async function openDetail(drama, source) {
    const overlay = $('detailOverlay');
    overlay.classList.add('open');
    state.detailOpen = true;
    state.currentDrama = drama;
    document.body.style.overflow = 'hidden';
    $('fabFilter').style.display = 'none';

    // Reset UI
    $('detailTitle').textContent = drama.drama_name || '';
    $('detailSynopsis').textContent = drama.description || 'Memuat...';
    $('detailChips').innerHTML = '';
    $('detailTags').innerHTML = '';
    $('episodeList').innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-dark-gray);">Memuat episode...</div>';
    $('episodeCounter').textContent = '';
    $('playerTitle').textContent = drama.drama_name || '';
    showPlayerLoading(true);
    stopPlayer();

    try {
      const cfg = SOURCE_CONFIG[source];
      const detailUrl = cfg.detailUrl(drama.drama_id);
      const data = await apiFetch(detailUrl);
      const detail = cfg.parseDetail(data);

      // Update info
      $('detailTitle').textContent = detail.drama_name || detail.title || drama.drama_name;
      $('detailSynopsis').textContent = detail.description || detail.synopsis_clean || detail.introduction || '-';

      // Chips
      const chips = $('detailChips');
      const epCount = detail.episode_count || detail.total_episode || 0;
      chips.innerHTML = `
        <span class="info-chip chip-primary">${epCount} Episode</span>
        <span class="info-chip" style="background:rgba(${hexToRgb(cfg.color)},0.16);color:${cfg.color};border:1px solid rgba(${hexToRgb(cfg.color)},0.4);">${cfg.label}</span>
      `;

      // Tags
      const tags = detail.tags || [];
      $('detailTags').innerHTML = tags.map(t => `<span class="tag-pill">${t}</span>`).join('');

      // Episode list
      let episodes = [];
      if (source === 'melolo') {
        episodes = (detail.video_list || []).map((v, i) => ({
          label: 'Episode ' + (v.episode || i + 1),
          video_id: v.video_id,
          index: i,
          cover: v.cover
        }));
      } else if (source === 'dramabox') {
        episodes = (detail.chapterList || []).map((c, i) => ({
          label: 'Episode ' + (c.chapterIndex != null ? c.chapterIndex + 1 : i + 1),
          chapterId: c.chapterId,
          chapterIndex: c.chapterIndex != null ? c.chapterIndex : i,
          index: i
        }));
      } else if (source === 'reelshort') {
        episodes = (detail.video_list || []).map((v, i) => ({
          label: v.title || 'Episode ' + (v.index || v.serialNumber || i + 1),
          chapterId: v.chapterId,
          index: i,
          serialNumber: v.serialNumber || v.index || i + 1
        }));
      } else if (source === 'freereels') {
        episodes = (detail.episode_list || []).map((ep, i) => ({
          label: ep.name || 'Episode ' + (i + 1),
          episode_id: ep.episode_id,
          index: i
        }));
      } else if (source === 'drakor') {
        episodes = (detail.data_episode || []).map((ep, i) => ({
          label: 'Episode ' + (i + 1),
          streaming_id: ep.id,
          id: ep.id,
          index: i
        }));
      }

      state.currentEpisodes = episodes;
      state.currentDrama = { ...drama, ...detail };
      $('episodeCounter').textContent = `0 / ${episodes.length}`;
      renderEpisodes(episodes, source);

      // Auto-play first episode
      if (episodes.length > 0) {
        playEpisode(0, source);
      } else {
        showPlayerLoading(false);
      }

    } catch(e) {
      console.error('Detail error:', e);
      $('detailSynopsis').textContent = 'Gagal memuat detail: ' + e.message;
      showPlayerLoading(false);
    }
  }

  function renderEpisodes(episodes, source) {
    const list = $('episodeList');
    list.innerHTML = '';

    episodes.forEach((ep, i) => {
      const item = document.createElement('div');
      item.className = 'episode-item';
      item.dataset.index = i;
      item.innerHTML = `
        <span class="ep-icon">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
        </span>
        <span class="ep-label">${ep.label}</span>
      `;
      item.onclick = () => playEpisode(i, source);
      list.appendChild(item);
    });
  }

  async function playEpisode(index, source) {
    const ep = state.currentEpisodes[index];
    if (!ep) return;

    state.currentEpIndex = index;
    $('episodeCounter').textContent = `${index + 1} / ${state.currentEpisodes.length}`;
    $('playerTitle').textContent = (state.currentDrama.drama_name || '') + ' - ' + ep.label;

    // Highlight active episode
    document.querySelectorAll('.episode-item').forEach(el => {
      el.classList.toggle('active', parseInt(el.dataset.index) === index);
    });

    // Scroll to active episode
    const activeEl = document.querySelector('.episode-item.active');
    if (activeEl) activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

    showPlayerLoading(true);
    stopPlayer();

    try {
      const cfg = SOURCE_CONFIG[source];
      let streamUrl;
      state.currentSubtitles = [];

      if (source === 'melolo') {
        streamUrl = cfg.streamUrl(ep.video_id);
      } else if (source === 'dramabox') {
        streamUrl = cfg.streamUrl(state.currentDrama.drama_id, ep.chapterIndex);
      } else if (source === 'reelshort') {
        streamUrl = cfg.streamUrl(state.currentDrama.drama_id, ep.serialNumber || index + 1);
      } else if (source === 'freereels') {
        streamUrl = cfg.streamUrl(state.currentDrama.drama_id, index + 1);
      } else if (source === 'drakor') {
        streamUrl = cfg.streamUrl(ep.streaming_id || ep.id);
      }

      const data = await apiFetch(streamUrl);
      const streamData = cfg.parseStream(data);
      state.currentStreamData = streamData;

      // Extract video URL based on source
      let videoUrl = '';
      let qualities = [];

      if (source === 'melolo') {
        // Melolo: qualities = [{ label, width, height, bitrate, codec, url }]
        // label sudah berisi definition dari API (misal "360p", "480p", "720p")
        qualities = (streamData.qualities || []).map(q => ({
          label: q.label || (q.height ? q.height + 'p' : 'default'),
          url: q.url || '',
          height: q.height || 0
        }));
        // Urutkan dari resolusi terendah ke tertinggi
        qualities.sort((a, b) => a.height - b.height);
        if (qualities.length) {
          const preferred = qualities.find(q => q.height === 720) 
            || qualities.find(q => q.label.includes('720')) 
            || qualities[qualities.length - 1];
          videoUrl = preferred.url;
          state.selectedQuality = preferred.label;
        }
      } else if (source === 'dramabox') {
        // Dramabox returns mp4_url or videoUrl in data
        videoUrl = streamData.mp4_url || streamData.videoUrl || streamData.video_url || '';
        if (streamData.definition_list) {
          qualities = streamData.definition_list.map(d => ({
            label: d.definition || d.code || 'default',
            url: d.url || ''
          }));
          if (qualities.length) {
            const preferred = qualities.find(q => q.label.includes('720')) || qualities[0];
            videoUrl = preferred.url || videoUrl;
            state.selectedQuality = preferred.label;
          }
        }
      } else if (source === 'reelshort') {
        // ReelShort videoList: [{ playUrl, encode, dpi, bitrate }]
        const videoList = streamData.videoList || [];
        qualities = videoList
          .filter(v => v.playUrl && v.dpi > 0)
          .map(v => ({
            label: v.dpi + 'p' + (v.encode ? ' ' + v.encode : ''),
            url: v.playUrl,
            dpi: v.dpi || 0,
            encode: v.encode || ''
          }));
        // Tambahkan entry dpi:0 sebagai "Auto" jika ada
        const autoEntry = videoList.find(v => v.playUrl && v.dpi === 0);
        if (autoEntry) qualities.push({ label: 'Auto', url: autoEntry.playUrl, dpi: 0, encode: autoEntry.encode || '' });
        if (qualities.length) {
          // Prefer H264 720p > H264 lainnya > 720p apapun > pertama
          const preferred = qualities.find(q => q.dpi === 720 && q.encode === 'H264')
            || qualities.find(q => q.encode === 'H264')
            || qualities.find(q => q.dpi === 720)
            || qualities[0];
          videoUrl = preferred.url;
          state.selectedQuality = preferred.label;
        }
      } else if (source === 'freereels') {
        // FreeReels: { video_url, m3u8_url, h264_m3u8, h265_m3u8, subtitles }
        if (streamData.h264_m3u8) qualities.push({ label: 'H264', url: streamData.h264_m3u8 });
        if (streamData.h265_m3u8) qualities.push({ label: 'H265', url: streamData.h265_m3u8 });
        // Fallback ke video_url jika tidak ada h264/h265
        if (!qualities.length && streamData.video_url) qualities.push({ label: 'Default', url: streamData.video_url });
        // Pilih H264 sebagai default (lebih kompatibel)
        const preferred = qualities.find(q => q.label === 'H264') || qualities[0];
        if (preferred) {
          videoUrl = preferred.url;
          state.selectedQuality = preferred.label;
        } else {
          videoUrl = streamData.video_url || streamData.m3u8_url || '';
          state.selectedQuality = 'auto';
        }
        // Muat subtitle jika tersedia
        if (streamData.subtitles && streamData.subtitles.length) {
          state.currentSubtitles = streamData.subtitles;
        }
      } else if (source === 'drakor') {
        // Drakor data_stream
        const streams = streamData.data_stream || data?.data_stream || [];
        if (streams.length) {
          const s = streams[0];
          if (s['720p']) { qualities.push({ label: '720p', url: s['720p'] }); videoUrl = s['720p']; }
          if (s['480p']) { qualities.push({ label: '480p', url: s['480p'] }); if (!videoUrl) videoUrl = s['480p']; }
          if (s['360p']) { qualities.push({ label: '360p', url: s['360p'] }); if (!videoUrl) videoUrl = s['360p']; }
          state.selectedQuality = qualities.length ? qualities[0].label : 'auto';
        }
      }

      state.currentQualities = qualities;
      renderQualityOptions(qualities);

      if (videoUrl) {
        loadVideo(videoUrl);
        // Load subtitles if available
        loadSubtitles();
        saveHistory(state.currentDrama, source, index);
      } else {
        showPlayerLoading(false);
        alert('Video tidak tersedia untuk episode ini');
      }

    } catch(e) {
      console.error('Stream error:', e);
      showPlayerLoading(false);
      alert('Gagal memuat stream: ' + e.message);
    }
  }

  // ============================================
  // VIDEO PLAYER
  // ============================================
  function loadVideo(url) {
    const video = $('videoPlayer');

    if (state.hlsInstance) {
      state.hlsInstance.destroy();
      state.hlsInstance = null;
    }

    if (url.includes('.m3u8')) {
      if (Hls.isSupported()) {
        const hls = new Hls({
          maxBufferLength: 30,
          maxMaxBufferLength: 60,
          startLevel: -1
        });
        hls.loadSource(url);
        hls.attachMedia(video);
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
          video.play().catch(() => {});
          showPlayerLoading(false);
        });
        hls.on(Hls.Events.ERROR, (_, data) => {
          if (data.fatal) {
            console.error('HLS fatal error:', data);
            showPlayerLoading(false);
          }
        });
        state.hlsInstance = hls;
      } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
        video.src = url;
        video.addEventListener('loadedmetadata', () => {
          video.play().catch(() => {});
          showPlayerLoading(false);
        }, { once: true });
      }
    } else {
      video.src = url;
      video.addEventListener('loadeddata', () => {
        video.play().catch(() => {});
        showPlayerLoading(false);
      }, { once: true });
      video.addEventListener('error', () => {
        showPlayerLoading(false);
        console.error('Video load error');
      }, { once: true });
    }
  }

  function stopPlayer() {
    const video = $('videoPlayer');
    video.pause();
    video.removeAttribute('src');
    // Remove subtitle tracks
    Array.from(video.querySelectorAll('track')).forEach(t => t.remove());
    state.currentSubtitles = [];
    video.load();
    if (state.hlsInstance) {
      state.hlsInstance.destroy();
      state.hlsInstance = null;
    }
  }

  function loadSubtitles() {
    const video = $('videoPlayer');
    // Remove existing tracks
    Array.from(video.querySelectorAll('track')).forEach(t => t.remove());
    if (!state.currentSubtitles || !state.currentSubtitles.length) return;
    state.currentSubtitles.forEach((sub, i) => {
      const track = document.createElement('track');
      track.kind = 'subtitles';
      track.label = sub.display_name || sub.language || 'Sub ' + (i + 1);
      track.srclang = (sub.language || '').split('-')[0] || 'id';
      track.src = sub.url || '';
      if (sub.language === 'id-ID' || sub.type === 'original') track.default = true;
      video.appendChild(track);
    });
  }

  function togglePlay() {
    const video = $('videoPlayer');
    if (video.paused) video.play().catch(() => {});
    else video.pause();
  }

  function seekVideo(val) {
    const video = $('videoPlayer');
    if (video.duration) {
      video.currentTime = (val / 100) * video.duration;
    }
  }

  function showPlayerLoading(show) {
    $('playerLoading').style.display = show ? 'block' : 'none';
  }

  function toggleFullscreen() {
    const container = $('playerContainer');
    if (document.fullscreenElement) {
      document.exitFullscreen();
    } else {
      container.requestFullscreen().catch(() => {});
    }
  }

  // Quality menu
  function renderQualityOptions(qualities) {
    const dropdown = $('qualityDropdown');
    const btn = $('qualityBtn');
    if (!qualities.length) {
      btn.textContent = 'Auto';
      dropdown.innerHTML = '';
      return;
    }
    btn.textContent = state.selectedQuality || qualities[0]?.label || 'Auto';
    dropdown.innerHTML = qualities.map(q =>
      `<button class="quality-option ${q.label === state.selectedQuality ? 'active' : ''}" onclick="selectQuality('${q.label}','${q.url}')">${q.label}</button>`
    ).join('');
  }

  function toggleQualityMenu() {
    $('qualityDropdown').classList.toggle('open');
  }

  function selectQuality(label, url) {
    state.selectedQuality = label;
    $('qualityBtn').textContent = label;
    $('qualityDropdown').classList.remove('open');
    document.querySelectorAll('.quality-option').forEach(o => o.classList.toggle('active', o.textContent === label));
    if (url) loadVideo(url);
  }

  // Player events
  const video = $('videoPlayer');

  video.addEventListener('timeupdate', () => {
    const t = video.currentTime;
    const d = video.duration || 0;
    $('timeDisplay').textContent = fmtTime(t) + ' / ' + fmtTime(d);
    if (d) $('seekBar').value = (t / d) * 100;
  });

  video.addEventListener('play', () => {
    $('playIcon').innerHTML = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>';
  });

  video.addEventListener('pause', () => {
    $('playIcon').innerHTML = '<path d="M8 5v14l11-7z"/>';
  });

  video.addEventListener('waiting', () => showPlayerLoading(true));
  video.addEventListener('canplay', () => showPlayerLoading(false));

  video.addEventListener('ended', () => {
    // Auto next episode
    if (state.currentEpIndex < state.currentEpisodes.length - 1) {
      const nextIdx = state.currentEpIndex + 1;
      const source = state.currentDrama?.source || detectSource();
      playEpisode(nextIdx, source);
    }
  });

  function detectSource() {
    const badge = document.querySelector('.detail-chips .info-chip:nth-child(2)');
    if (!badge) return 'melolo';
    const text = badge.textContent.toLowerCase().trim();
    return SOURCES.find(s => SOURCE_CONFIG[s].label.toLowerCase() === text) || 'melolo';
  }

  function closeDetail() {
    stopPlayer();
    $('detailOverlay').classList.remove('open');
    state.detailOpen = false;
    document.body.style.overflow = '';
    $('fabFilter').style.display = '';
  }

  // Close quality dropdown on outside click
  document.addEventListener('click', (e) => {
    if (!e.target.closest('#qualityBtn') && !e.target.closest('#qualityDropdown')) {
      $('qualityDropdown').classList.remove('open');
    }
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (state.detailOpen) {
      const video = $('videoPlayer');
      switch(e.key) {
        case 'Escape': closeDetail(); break;
        case ' ':
        case 'k': e.preventDefault(); togglePlay(); break;
        case 'ArrowLeft': e.preventDefault(); video.currentTime = Math.max(0, video.currentTime - 5); break;
        case 'ArrowRight': e.preventDefault(); video.currentTime = Math.min(video.duration || 0, video.currentTime + 5); break;
        case 'f': toggleFullscreen(); break;
        case 'n':
          if (state.currentEpIndex < state.currentEpisodes.length - 1) {
            playEpisode(state.currentEpIndex + 1, detectSource());
          }
          break;
        case 'p':
          if (state.currentEpIndex > 0) {
            playEpisode(state.currentEpIndex - 1, detectSource());
          }
          break;
      }
    }
  });

  // ============================================
  // HEX TO RGB HELPER
  // ============================================
  function hexToRgb(hex) {
    const r = parseInt(hex.slice(1,3), 16);
    const g = parseInt(hex.slice(3,5), 16);
    const b = parseInt(hex.slice(5,7), 16);
    return r + ',' + g + ',' + b;
  }

  // Proxy thumbnail melalui wsrv.nl (untuk Melolo yang pakai HEIC)
  function proxyThumb(url, source) {
    if (!url) return '';
    if (source === 'melolo') {
      return 'https://wsrv.nl/?url=' + encodeURIComponent(url) + '&output=webp&w=400&q=80';
    }
    return url;
  }

  // ============================================
  // INIT
  // ============================================
  switchTab('home');
    // ============================================
  // BACK BUTTON HANDLING (HISTORY API)
  // ============================================
  
  // Fungsi untuk menangani perubahan history (saat tombol back ditekan)
  window.addEventListener('popstate', (event) => {
    if (state.detailOpen) {
      // Jika detail sedang terbuka, tutup detailnya (jangan keluar browser)
      closeDetailSilently(); 
    }
  });

  // Fungsi tutup detail tanpa memicu pushState lagi (agar tidak loop)
  function closeDetailSilently() {
    stopPlayer();
    $('detailOverlay').classList.remove('open');
    state.detailOpen = false;
    document.body.style.overflow = '';
    $('fabFilter').style.display = '';
  }

  // Modifikasi fungsi openDetail agar menambahkan entry ke history
  const originalOpenDetail = openDetail;
  openDetail = async function(drama, source) {
    // Tambahkan state baru ke browser history sebelum membuka detail
    history.pushState({ detailView: true }, "");
    return originalOpenDetail(drama, source);
  };

  // Modifikasi fungsi closeDetail agar sinkron dengan history browser
  const originalCloseDetail = closeDetail;
  closeDetail = function() {
    if (state.detailOpen) {
      // Jika user klik tombol silang (X), kita "back" secara programmatik
      // Ini akan memicu event 'popstate' di atas yang kemudian memanggil closeDetailSilently
      history.back();
    }
  };
</script>

</body>
</html>